# 에이전트 작업 절차
1. 아래 "## 개발자 요구사항" 섹션의 내용을 바탕으로 코드 베이스를 검토하고 작업을 준비한다.
2. 만약 해당 이 파일이 마지막 섹션이 "## 개발자 요구사항 수정" 또는 "## 개발자 요구사항 추가" 또는 "## 개발자 검토답변" 등 개발자가 작성한 섹션이라면 해당 부분부터 작업하도록 한다.
3. 작업을 진행하기 전에 개발자의 추가 검토가 필요한 내용이 있다면 개발자에게 문의할 내용을 이 파일의 아래에 이어서 "## 에이전트 검토요청"으로 섹션을 추가하고 작업을 종료한다.
4. 작업을 완료한 경우 내용 이 파일의 아래에 이어서 "## 에이전트 작업수행내용" 섹션을 추가하고 작업한 상세 내용을 작성한다.

## 개발자 요구사항
1. 개발자가 아래 문제에 대해 최종 검토를 마치고 최종적으로 수정작업을 요청하기 전까지 코드베이스 수정을 하지 않는다.
2. 검토가 필요한 대상 핵심 엔티티는 다음과 같다. [Talk.java](../../src/main/java/maskun/quietchatter/talk/domain/Talk.java)
3. 매일 정해진 시각 (0시)에 아직 숨겨지지 않은 Talk 엔티티의 `dataToHidden`이 경과한 엔티티를 `isHidden` 플래그 필드를 true 변경하고자한다. 
4. 개발자는 스프링 스케쥴 기능을 이용하여 정해진 시간에 데이터베이스를 조회하고 일괄 업데이트를 하려고 한다. JPA를 사용하지 않고 JDBC Template의 배치성 쿼리를 사용하고자 한다.
5. 해당 구현 설계가 적합한지 검토하고 다른 추천할 옵션이 있다면 이 파일의 아래에 "## 에이전트 검토수행내용" 섹션을 추가하여 작성한다. 
6. 검토내용에는 트레이드 오프가 있다면 표시하고, 그리고 업계의 관행적인지 여부도 포함한다.

## 에이전트 검토수행내용

제안하신 **Spring Scheduling + JDBC Template**을 이용한 일괄 업데이트 방식은 현재 프로젝트 규모와 요구사항에 비추어 볼 때 **매우 적절하고 합리적인 선택**입니다.

### 1. 제안 방식 검토 (Spring Scheduling + JDBC Template)

*   **장점 (Pros):**
    *   **성능 효율성**: JPA의 Dirty Checking 방식은 수천~수만 건의 데이터를 메모리에 로드해야 하므로 오버헤드가 큽니다. JDBC Template을 사용한 단일 `UPDATE` 쿼리는 DB 레벨에서 최적화되어 실행되므로 훨씬 빠르고 자원 소모가 적습니다.
    *   **단순성**: 별도의 복잡한 배치 프레임워크 설정 없이 구현이 가능하여 유지보수가 용이합니다.
*   **단점 및 주의사항 (Cons):**
    *   **분산 환경 이슈**: 서버가 여러 대(Scale-out)인 경우, 동일한 스케줄러가 각 서버에서 중복 실행될 수 있습니다. 이를 방지하기 위해 `ShedLock` 같은 라이브러리를 사용하거나 DB 레벨의 락이 필요합니다.
    *   **트랜잭션 크기**: 업데이트 대상 데이터가 수백만 건 이상으로 매우 많을 경우, 단일 트랜잭션이 길어져 DB 락(Lock) 경합이 발생할 수 있습니다. (현재 서비스 규모에서는 무시 가능할 것으로 보입니다.)

### 2. 대안 및 추천 옵션

#### 옵션 A: Spring Batch (추천하지 않음)
*   **특징**: 대용량 데이터 처리, 실패 시 재시도, 로깅, 모니터링에 특화.
*   **트레이드 오프**: 단순 업데이트 작업 하나를 위해 도입하기에는 설정 오버헤드가 너무 큽니다. 데이터 양이 기하급수적으로 늘어날 것이 예상될 때 고려할 만합니다.

#### 옵션 B: JPA @Modifying 쿼리 (추천)
*   **특징**: `TalkRepository`에 `@Modifying`과 `@Query`를 사용하여 `UPDATE talk SET is_hidden = true WHERE ...` 쿼리를 직접 작성.
*   **장점**: JDBC Template을 직접 사용하는 것보다 영속성 계층의 일관성을 유지하기 쉽고 코드가 간결합니다.
*   **관행**: Spring Data JPA를 사용하는 환경에서는 JDBC Template을 별도로 주입받기보다 Repository 내에서 벌크 연산을 처리하는 것이 더 일반적입니다.

### 3. 업계 관행 및 결론

업계에서는 단순한 상태 변경 배치 작업의 경우 **Spring Scheduling + Bulk Update (JPA @Modifying 또는 JDBC Template)** 방식을 가장 선호합니다.

**최종 추천:**
1.  **구현 방식**: `TalkRepository`에 `@Modifying` 쿼리를 작성하여 처리하는 방식을 추천합니다. (JDBC Template과 성능 차이는 거의 없으면서 코드 응집도가 높습니다.)
2.  **중복 실행 방지**: 향후 서버 확장성을 고려하여 `ShedLock` 도입을 검토하세요.
3.  **인덱스**: `date_to_hidden`과 `is_hidden` 컬럼에 복합 인덱스가 없다면, 조회 성능을 위해 인덱스 추가를 고려해야 합니다. (현재 `Talk.java`에는 `created_at` 등에만 인덱스가 있습니다.)

---
위 검토 내용에 대해 동의하신다면, 실제 구현(스케줄러 클래스 생성 및 리포지토리 수정) 작업을 진행하겠습니다. 추가 의견이 있으시면 말씀해 주세요.

## 개발자 검토답변
1. 아래 내용에 맞춰 코딩을 진행한다.
2. Spring Scheduling + JPA @Modifying 쿼리 방식으로 해당 요구사항을 구현하고자 한다.
3. 성능을 위해 `Talk` 엔티티에 해당 작업에 필요한 조회에 쓰일 컬럼에 인덱스를 설정한다.
4. 관심사의 분리를 위해 `@Modifying` 을 수행하는 추상 리파지토리는 별도로 분리한다. 
5. 테스트 코드를 작성한다.

## 에이전트 작업수행내용
1. **엔티티 수정**: `Talk.java`에 `date_to_hidden`과 `is_hidden` 컬럼에 대한 복합 인덱스(`idx_talk_date_to_hidden_is_hidden`)를 추가하였습니다.
2. **리포지토리 생성**: 벌크 업데이트 처리를 위한 `TalkBulkRepository` 인터페이스를 생성하고, `@Modifying` 쿼리를 사용하여 만료된 톡을 숨김 처리하는 `hideExpiredTalks` 메서드를 정의하였습니다.
3. **스케줄러 구현**: `TalkAutoHiddenProcessor` 클래스를 생성하여 매일 0시에 `TalkBulkRepository`를 호출하도록 구현하였습니다.
4. **설정 활성화**: `QuietChatterApplication`에 `@EnableScheduling` 어노테이션을 추가하여 스케줄링 기능을 활성화하였습니다.
5. **테스트 코드 작성**: `TalkBulkRepositoryTest`를 작성하여 날짜 경과에 따른 숨김 처리 로직이 정상적으로 작동하는지 검증하였습니다.
